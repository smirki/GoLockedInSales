Path: c:\Users\Smirk\Documents\Programming\Chat\.gitignore
Directory: c:\Users\Smirk\Documents\Programming\Chat
Contents:
node_modules/


Path: c:\Users\Smirk\Documents\Programming\Chat\app.js
Directory: c:\Users\Smirk\Documents\Programming\Chat
Contents:
const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const http = require('http');
const socketio = require('socket.io');
const cookieParser = require('cookie-parser');
const winston = require('winston');

// Setup Winston logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}

const app = express();
const server = http.createServer(app);
const io = socketio(server);

app.use(bodyParser.json());
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

const usersFilePath = path.join(__dirname, 'data/users.json');
const chatsFilePath = path.join(__dirname, 'data/chats.json');

const readUsers = () => {
    try {
        const usersData = fs.readFileSync(usersFilePath);
        return JSON.parse(usersData);
    } catch (error) {
        logger.error('Error reading users file', { error });
        return [];
    }
};

const writeUsers = (users) => {
    try {
        fs.writeFileSync(usersFilePath, JSON.stringify(users, null, 2));
    } catch (error) {
        logger.error('Error writing users file', { error });
    }
};

const readChats = () => {
    try {
        const chatsData = fs.readFileSync(chatsFilePath);
        return JSON.parse(chatsData);
    } catch (error) {
        logger.error('Error reading chats file', { error });
        return [];
    }
};

const writeChats = (chats) => {
    try {
        fs.writeFileSync(chatsFilePath, JSON.stringify(chats, null, 2));
    } catch (error) {
        logger.error('Error writing chats file', { error });
    }
};

const staffViewingChat = new Map(); // Track staff viewing each chat

// User routes
app.post('/api/users/register', async (req, res) => {
    try {
        const { username, password } = req.body;
        const users = readUsers();
        const userExists = users.find(user => user.username === username);

        if (userExists) {
            return res.status(400).json({ message: 'User already exists' });
        }

        const hashedPassword = await bcrypt.hash(password, 10);
        const userId = users.length ? users[users.length - 1].id + 1 : 1;
        users.push({ id: userId, username, password: hashedPassword });
        writeUsers(users);

        logger.info('User registered', { userId, username });
        res.status(201).json({ message: 'User registered successfully' });
    } catch (error) {
        logger.error('Error in user registration', { error });
        res.status(500).json({ message: 'Internal server error' });
    }
});

app.post('/api/users/login', async (req, res) => {
    try {
        const { username, password } = req.body;
        const users = readUsers();
        const user = users.find(user => user.username === username);

        if (!user || !await bcrypt.compare(password, user.password)) {
            return res.status(400).json({ message: 'Invalid credentials' });
        }

        const token = jwt.sign({ id: user.id, username: user.username }, 'secret', { expiresIn: '1h' });
        res.cookie('token', token, { httpOnly: true });
        logger.info('User logged in', { userId: user.id, username });
        res.json({ message: 'Login successful', userId: user.id, username: user.username });
    } catch (error) {
        logger.error('Error in user login', { error });
        res.status(500).json({ message: 'Internal server error' });
    }
});

app.get('/api/users/logout', (req, res) => {
    res.clearCookie('token');
    logger.info('User logged out');
    res.json({ message: 'Logout successful' });
});

// Middleware to verify token
const verifyToken = (req, res, next) => {
    const token = req.cookies.token;
    if (!token) {
        return res.status(401).json({ message: 'No token provided' });
    }

    try {
        const decoded = jwt.verify(token, 'secret');
        req.user = decoded;
        next();
    } catch (err) {
        logger.error('Invalid token', { error: err });
        return res.status(401).json({ message: 'Invalid token' });
    }
};

app.get('/api/users/me', verifyToken, (req, res) => {
    res.json({ id: req.user.id, username: req.user.username });
});

app.get('/api/staff/dashboard', verifyToken, (req, res) => {
    const chats = readChats();
    res.json(chats);
});


// Socket.io chat handling
io.on('connection', socket => {
    logger.info('New WebSocket connection');

    socket.on('joinChat', ({ userId, username }) => {
        socket.join(userId.toString());
        logger.info('User joined chat', { userId, username });
    });

    socket.on('chatMessage', msg => {
        try {
            const chats = readChats();
            const { userId, username, text } = msg;
            let chat = chats.find(chat => chat.userId === userId);

            if (!chat) {
                chat = { userId, username, messages: [], needsResponse: true };
                chats.push(chat);
            } else {
                chat.needsResponse = true; // Mark chat as needing a response
            }

            const newMessage = { sender: username, text, timestamp: new Date().toISOString(), read: false };
            chat.messages.push(newMessage);
            writeChats(chats);

            io.to(userId.toString()).emit('message', newMessage);
            io.to('staff').emit('newUserMessage', { userId, message: newMessage });
            logger.info('Chat message sent', { userId, username });
        } catch (error) {
            logger.error('Error processing chat message', { error });
        }
    });

    socket.on('responseMessage', msg => {
        try {
            const chats = readChats();
            const { userId, text } = msg;
            const chat = chats.find(chat => chat.userId === userId);

            if (chat) {
                const newMessage = { sender: 'Staff', text, timestamp: new Date().toISOString(), read: false };
                chat.messages.push(newMessage);
                chat.needsResponse = false; // Mark chat as responded to
                writeChats(chats);
                io.to(userId.toString()).emit('message', newMessage);
                io.to('staff').emit('staffMessageSent', { userId, message: newMessage });
                logger.info('Staff response sent', { userId });
            } else {
                logger.warn('Chat not found for staff response', { userId });
            }
        } catch (error) {
            logger.error('Error processing staff response', { error });
        }
    });

    socket.on('staffJoin', () => {
        socket.join('staff');
        logger.info('Staff joined chat');
    });

    socket.on('markAsRead', userId => {
        try {
            const chats = readChats();
            const chat = chats.find(chat => chat.userId === userId);

            if (chat) {
                chat.messages.forEach(message => {
                    if (message.sender !== 'Staff') {
                        message.read = true;
                    }
                });
                writeChats(chats);
                logger.info('Messages marked as read', { userId });
            } else {
                logger.warn('Chat not found for marking as read', { userId });
            }
        } catch (error) {
            logger.error('Error marking messages as read', { error });
        }
    });

    socket.on('staffViewing', ({ userId }) => {
        if (!staffViewingChat.has(userId)) {
            staffViewingChat.set(userId, 0);
        }
        staffViewingChat.set(userId, staffViewingChat.get(userId) + 1);
        io.to('staff').emit('viewingCount', { userId, count: staffViewingChat.get(userId) });
    });

    socket.on('stopViewing', ({ userId }) => {
        if (staffViewingChat.has(userId)) {
            staffViewingChat.set(userId, staffViewingChat.get(userId) - 1);
            io.to('staff').emit('viewingCount', { userId, count: staffViewingChat.get(userId) });
        }
    });

    socket.on('sharedTextboxUpdate', ({ userId, text }) => {
        io.to('staff').emit('sharedTextboxUpdate', { userId, text });
    });
    

    socket.on('disconnect', () => {
        logger.info('User disconnected');
        // Handle disconnecting staff members from the chat viewing count
        // This is just a placeholder, additional logic to determine the userId might be needed
    });
});

const PORT = process.env.PORT || 3009;
server.listen(PORT, () => {
    logger.info(`Server running on port ${PORT}`);
});


Path: c:\Users\Smirk\Documents\Programming\Chat\write.py
Directory: c:\Users\Smirk\Documents\Programming\Chat
Contents:
import os

def create_or_update_file(file_path, contents):
    # Create directories if they do not exist
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    # Write the contents to the file
    with open(file_path, 'w') as file:
        file.write(contents)
    print(f"File created/updated: {file_path}")

def process_output_file(output_file):
    with open(output_file, 'r') as file:
        lines = file.readlines()

    current_path = None
    current_contents = []
    
    for line in lines:
        if line.startswith('Path:'):
            # If there is already a file being processed, write its contents
            if current_path:
                create_or_update_file(current_path, ''.join(current_contents))
            
            # Start processing a new file
            current_path = line.split(': ')[1].strip()
            current_contents = []
        elif line.startswith('Directory:'):
            continue  # Ignore this line
        elif line.startswith('Contents:'):
            continue  # Ignore this line
        else:
            current_contents.append(line)

    # Write the last file being processed
    if current_path:
        create_or_update_file(current_path, ''.join(current_contents))

if __name__ == "__main__":
    # Path to the output file
    output_file = 'output.txt'
    print(f"Processing output file: {output_file}")
    process_output_file(output_file)
    print("Processing complete.")


Path: c:\Users\Smirk\Documents\Programming\Chat\data\chats.json
Directory: c:\Users\Smirk\Documents\Programming\Chat\data
Contents:
[
  {
    "userId": 1,
    "username": "manavmaj2001@gmail.com",
    "messages": [
      {
        "sender": "manavmaj2001@gmail.com",
        "text": "hi",
        "timestamp": "2024-07-23T03:04:17.921Z",
        "read": true
      },
      {
        "sender": "Staff",
        "text": "yeah u better say hi",
        "timestamp": "2024-07-23T03:04:27.605Z",
        "read": false
      },
      {
        "sender": "Staff",
        "text": "what is happening",
        "timestamp": "2024-07-23T03:04:46.801Z",
        "read": false
      },
      {
        "sender": "Staff",
        "text": "lol",
        "timestamp": "2024-07-23T03:04:49.123Z",
        "read": false
      },
      {
        "sender": "Staff",
        "text": "this is funny",
        "timestamp": "2024-07-23T03:08:55.748Z",
        "read": false
      },
      {
        "sender": "a",
        "text": "hi",
        "timestamp": "2024-07-23T03:27:28.853Z",
        "read": true
      },
      {
        "sender": "a",
        "text": "huh",
        "timestamp": "2024-07-23T03:27:34.324Z",
        "read": false
      },
      {
        "sender": "a",
        "text": "this is so weird",
        "timestamp": "2024-07-23T03:27:39.545Z",
        "read": false
      }
    ],
    "needsResponse": true
  }
]

Path: c:\Users\Smirk\Documents\Programming\Chat\data\users.json
Directory: c:\Users\Smirk\Documents\Programming\Chat\data
Contents:
[
  {
    "id": 1,
    "username": "a",
    "password": "$2b$10$pD21GiDf/YAInHbsXJLPIO.P9aRlLWFVlqgaLWEjupRIufcn17P3i"
  }
]

Path: c:\Users\Smirk\Documents\Programming\Chat\public\chat.html
Directory: c:\Users\Smirk\Documents\Programming\Chat\public
Contents:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accountability Chat</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #chat-container {
            max-width: 600px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        #messages {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 20px;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        .user-message {
            background-color: #e6f2ff;
            text-align: right;
        }
        .staff-message {
            background-color: #f0f0f0;
            text-align: left;
        }
        #chat-form {
            display: flex;
        }
        #msg-input {
    flex-grow: 1;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    max-width: calc(100% - 120px);
}

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        #welcome-message {
            text-align: center;
            margin-bottom: 20px;
        }
        #logout-btn {
            display: block;
            width: 100%;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <h1 id="welcome-message">Welcome</h1>
        <div id="messages"></div>
        <form id="chat-form">
            <input id="msg-input" type="text" placeholder="Type your message..." autocomplete="off" required>
            <button type="submit">Send</button>
        </form>
        <button id="logout-btn">Logout</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script>
        const socket = io();
        
        const userId = Number(localStorage.getItem('userId'));
        const username = localStorage.getItem('username');
        const welcomeMessage = document.getElementById('welcome-message');
        const messagesDiv = document.getElementById('messages');
        const chatForm = document.getElementById('chat-form');
        const msgInput = document.getElementById('msg-input');
        const logoutBtn = document.getElementById('logout-btn');

        welcomeMessage.textContent = `Welcome, ${username}`;

        socket.emit('joinChat', { userId, username });

        socket.on('message', addMessageToChat);

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            Swal.fire('Error', 'Failed to connect to the server. Please try again later.', 'error');
        });

        chatForm.addEventListener('submit', sendMessage);
        logoutBtn.addEventListener('click', logout);

        function sendMessage(e) {
    e.preventDefault();
    if (msgInput.value) {
        const msg = {
            userId: userId,
            username: username,
            text: msgInput.value,
            timestamp: new Date().toISOString()
        };
        socket.emit('chatMessage', msg, (error) => {
            if (error) {
                console.error('Error sending message:', error);
                Swal.fire('Error', 'Failed to send message. Please try again.', 'error');
            } else {
                addMessageToChat(msg);
                msgInput.value = ''; // Clear the input box
            }
        });
    }
}


        function addMessageToChat(message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(message.sender === username ? 'user-message' : 'staff-message');
            
            const sender = message.sender === username ? 'You' : 'Staff';
            messageElement.innerHTML = `
                <strong>${sender}:</strong> ${message.text}
                <br>
                <small>${new Date(message.timestamp).toLocaleTimeString()}</small>
            `;
            
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function logout() {
            fetch('/api/users/logout')
                .then(response => response.json())
                .then(data => {
                    if (data.message === 'Logout successful') {
                        localStorage.clear();
                        window.location.href = '/login.html';
                    }
                })
                .catch(error => {
                    console.error('Logout error:', error);
                    Swal.fire('Error', 'Failed to logout. Please try again.', 'error');
                });
        }

        // Load chat history
        fetch('/api/users/me')
            .then(response => response.json())
            .then(user => {
                fetch('/api/staff/dashboard')
                    .then(response => response.json())
                    .then(chats => {
                        const chat = chats.find(c => c.userId === user.id);
                        if (chat) {
                            chat.messages.forEach(addMessageToChat);
                            socket.emit('markAsRead', user.id);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading chat history:', error);
                        Swal.fire('Error', 'Failed to load chat history. Please refresh the page.', 'error');
                    });
            })
            .catch(error => {
                console.error('Error getting user info:', error);
                Swal.fire('Error', 'Failed to load user information. Please try logging in again.', 'error');
            });
    </script>
</body>
</html>

Path: c:\Users\Smirk\Documents\Programming\Chat\public\index.html
Directory: c:\Users\Smirk\Documents\Programming\Chat\public
Contents:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accountability Service</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        header {
            background-color: #4CAF50;
            color: white;
            padding: 10px 0;
        }
        section {
            padding: 20px;
        }
        .cta-button {
            background-color: #4CAF50;
            color: white;
            padding: 15px 30px;
            margin: 20px 0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .cta-button:hover {
            background-color: #45a049;
        }
        footer {
            background-color: #4CAF50;
            color: white;
            padding: 10px 0;
            position: fixed;
            width: 100%;
            bottom: 0;
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to Your Accountability Service</h1>
        <p>Stay on track and achieve your goals with our help</p>
    </header>
    <section>
        <h2>Why Choose Us?</h2>
        <p>Our service provides you with dedicated staff to help you stay accountable and achieve your goals.</p>
        <p>Whether you need reminders, motivation, or just someone to talk to, we're here for you.</p>
        <h3>Features:</h3>
        <ul>
            <li>24/7 Support</li>
            <li>Personalized Reminders</li>
            <li>Goal Tracking</li>
            <li>Motivational Messages</li>
        </ul>
        <button class="cta-button" onclick="location.href='/register.html'">Sign Up Now</button>
        <p>Already have an account? <a href="/login.html">Login here</a></p>
    </section>
    <footer>
        <p>&copy; 2024 Accountability Service. All rights reserved.</p>
    </footer>
</body>
</html>


Path: c:\Users\Smirk\Documents\Programming\Chat\public\login.html
Directory: c:\Users\Smirk\Documents\Programming\Chat\public
Contents:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Login</title>
</head>
<body>
    <form id="login-form">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Login</button>
    </form>

    <script>
        document.getElementById('login-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
    
            fetch('/api/users/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            })
            .then(response => response.json())
            .then(data => {
                if (data.username) {
                    localStorage.setItem('userId', data.userId);
                    localStorage.setItem('username', data.username);
                    window.location.href = '/chat.html'; // Redirect to chat page
                } else {
                    alert(data.message);
                }
            });
        });
    </script>
    
</body>
</html>


Path: c:\Users\Smirk\Documents\Programming\Chat\public\register.html
Directory: c:\Users\Smirk\Documents\Programming\Chat\public
Contents:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Register</title>
</head>
<body>
    <form id="register-form">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Register</button>
    </form>

    <script>
        document.getElementById('register-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            fetch('/api/users/register', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ username, password })
            })
            .then(response => response.json())
            .then(data => {
                alert(data.message);
                if (data.message === 'User registered successfully') {
                    window.location.href = '/login.html'; // Redirect to login page
                }
            });
        });
    </script>
</body>
</html>


Path: c:\Users\Smirk\Documents\Programming\Chat\public\staff.html
Directory: c:\Users\Smirk\Documents\Programming\Chat\public
Contents:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Staff Dashboard</title>
    <style>
        #dashboard-container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 10px;
            background-color: #f9f9f9;
        }
        .chat-list {
            width: 30%;
            padding: 10px;
            border-right: 1px solid #ddd;
        }
        .chat {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            background-color: #fff;
        }
        .chat:hover {
            background-color: #f0f0f0;
        }
        .chat.needs-response {
            border-left: 5px solid red;
        }
        .chat-messages {
            width: 70%;
            padding: 10px;
        }
        .chat-messages ul {
            list-style: none;
            padding: 0;
            max-height: 400px;
            overflow-y: scroll;
        }
        .chat-messages ul li {
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .chat-messages ul .user-message {
            background-color: #d4f1c5;
            text-align: right;
        }
        .chat-messages ul .staff-message {
            background-color: #f1d4d4;
            text-align: left;
        }
        .chat-messages ul .timestamp {
            display: block;
            font-size: 0.8em;
            color: #999;
        }
        .viewing-count {
            font-size: 0.9em;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="dashboard-container">
        <div class="chat-list" id="conversations"></div>
        <div class="chat-messages">
            <h3 id="chat-header">Select a chat</h3>
            <ul id="messages"></ul>
            <form id="response-form">
                <input id="response-msg" type="text" placeholder="Enter response..." autocomplete="off" required>
                <button type="submit">Send</button>
            </form>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script>
        const socket = io();
        let currentChatUserId = null;
        let responseMsg = document.getElementById('response-msg');

        socket.emit('staffJoin');

        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
            Swal.fire('Error', 'Failed to connect to the server. Please try again later.', 'error');
        });

        function loadChats() {
    fetch('/api/staff/dashboard')
        .then(response => response.json())
        .then(chats => {
            const conversationsDiv = document.getElementById('conversations');
            conversationsDiv.innerHTML = '';
            chats.sort((a, b) => new Date(b.messages[b.messages.length - 1].timestamp) - new Date(a.messages[a.messages.length - 1].timestamp));
            chats.forEach(chat => {
                const chatDiv = document.createElement('div');
                chatDiv.classList.add('chat');
                if (chat.needsResponse) {
                    chatDiv.classList.add('needs-response');
                }
                chatDiv.dataset.userId = chat.userId;
                chatDiv.innerHTML = `
                    <h4>${chat.username}</h4>
                    <p>Messages: ${chat.messages.length}</p>
                    <p>Last Message: ${new Date(chat.messages[chat.messages.length - 1].timestamp).toLocaleTimeString()}</p>
                    <p class="viewing-count" id="viewing-count-${chat.userId}">Viewing: 0</p>
                `;
                chatDiv.addEventListener('click', () => {
                    openChat(chat.userId);
                    socket.emit('markAsRead', chat.userId);
                });
                conversationsDiv.appendChild(chatDiv);
            });
        })
        .catch(error => {
            console.error('Error loading chats:', error);
            Swal.fire('Error', 'Failed to load chats. Please refresh the page.', 'error');
        });
}


        function openChat(userId) {
            if (currentChatUserId) {
                socket.emit('stopViewing', { userId: currentChatUserId });
            }
            currentChatUserId = userId;
            socket.emit('staffViewing', { userId });
            fetch('/api/staff/dashboard')
                .then(response => response.json())
                .then(chats => {
                    const chat = chats.find(c => c.userId === userId);
                    if (chat) {
                        document.getElementById('chat-header').innerText = `Chat with ${chat.username}`;
                        const messagesUl = document.getElementById('messages');
                        messagesUl.innerHTML = '';
                        chat.messages.forEach(msg => {
                            addMessageToChat(msg);
                        });
                        scrollToBottom();
                    }
                })
                .catch(error => {
                    console.error('Error opening chat:', error);
                    Swal.fire('Error', 'Failed to open chat. Please try again.', 'error');
                });
        }

        function respond(event) {
            event.preventDefault();
            const responseMsgText = responseMsg.value;
            if (responseMsgText && currentChatUserId) {
                const msg = { userId: currentChatUserId, text: responseMsgText, timestamp: new Date().toISOString() };

                socket.emit('responseMessage', msg, (error) => {
                    if (error) {
                        console.error('Error sending response:', error);
                        Swal.fire('Error', 'Failed to send response. Please try again.', 'error');
                    } else {
                        addMessageToChat({ sender: 'Staff', ...msg });
                        responseMsg.value = '';
                        scrollToBottom();
                    }
                });
            }
        }

        socket.on('newUserMessage', ({ userId, message }) => {
            if (userId === currentChatUserId) {
                addMessageToChat(message);
                scrollToBottom();
            }
            loadChats(); // Reload chat list to update last message
        });

        socket.on('staffMessageSent', ({ userId, message }) => {
            if (userId === currentChatUserId) {
                addMessageToChat(message);
                scrollToBottom();
            }
        });

        socket.on('viewingCount', ({ userId, count }) => {
            const viewingCountElement = document.getElementById(`viewing-count-${userId}`);
            if (viewingCountElement) {
                viewingCountElement.textContent = `Viewing: ${count}`;
            }
        });

        function addMessageToChat(message) {
            const messagesUl = document.getElementById('messages');
            const li = document.createElement('li');
            li.classList.add(message.sender === 'Staff' ? 'staff-message' : 'user-message');
            li.innerHTML = `
                <strong>${message.sender}:</strong> ${message.text}
                <br>
                <small>${new Date(message.timestamp).toLocaleTimeString()}</small>
            `;
            messagesUl.appendChild(li);
        }

        function scrollToBottom() {
            const messagesUl = document.getElementById('messages');
            messagesUl.scrollTop = messagesUl.scrollHeight;
        }

        document.getElementById('response-form').addEventListener('submit', respond);

        loadChats();

        // Periodically reload chats to check for new messages
        setInterval(loadChats, 30000); // Reload every 30 seconds

        responseMsg.addEventListener('input', () => {
    if (currentChatUserId) {
        socket.emit('sharedTextboxUpdate', { userId: currentChatUserId, text: responseMsg.value });
    }
});

socket.on('sharedTextboxUpdate', ({ userId, text }) => {
    if (userId === currentChatUserId) {
        responseMsg.value = text;
    }
});

        window.addEventListener('beforeunload', () => {
            if (currentChatUserId) {
                socket.emit('stopViewing', { userId: currentChatUserId });
            }
        });

        window.addEventListener('blur', () => {
            if (currentChatUserId) {
                socket.emit('stopViewing', { userId: currentChatUserId });
            }
        });

        window.addEventListener('focus', () => {
            if (currentChatUserId) {
                socket.emit('staffViewing', { userId: currentChatUserId });
            }
        });
    </script>
</body>
</html>


Path: c:\Users\Smirk\Documents\Programming\Chat\routes\staff.js
Directory: c:\Users\Smirk\Documents\Programming\Chat\routes
Contents:
const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');

const chatsFilePath = path.join(__dirname, '../data/chats.json');

const readChats = () => {
    const chatsData = fs.readFileSync(chatsFilePath);
    return JSON.parse(chatsData);
};

const writeChats = (chats) => {
    fs.writeFileSync(chatsFilePath, JSON.stringify(chats, null, 2));
};

router.get('/dashboard', (req, res) => {
    const chats = readChats();
    res.json(chats);
});

router.post('/respond', (req, res) => {
    const { userId, response } = req.body;
    const chats = readChats();
    const chat = chats.find(chat => chat.userId === userId);

    if (chat) {
        chat.responses.push(response);
        writeChats(chats);
        return res.status(200).json({ message: 'Response sent' });
    }

    res.status(400).json({ message: 'Chat not found' });
});

module.exports = router;


Path: c:\Users\Smirk\Documents\Programming\Chat\routes\users.js
Directory: c:\Users\Smirk\Documents\Programming\Chat\routes
Contents:
const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const usersFilePath = path.join(__dirname, '../data/users.json');

const readUsers = () => {
    const usersData = fs.readFileSync(usersFilePath);
    return JSON.parse(usersData);
};

const writeUsers = (users) => {
    fs.writeFileSync(usersFilePath, JSON.stringify(users, null, 2));
};

router.post('/register', async (req, res) => {
    const { username, password } = req.body;
    const users = readUsers();
    const userExists = users.find(user => user.username === username);

    if (userExists) {
        return res.status(400).json({ message: 'User already exists' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    users.push({ username, password: hashedPassword });
    writeUsers(users);

    res.status(201).json({ message: 'User registered successfully' });
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    const users = readUsers();
    const user = users.find(user => user.username === username);

    if (!user || !await bcrypt.compare(password, user.password)) {
        return res.status(400).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign({ username: user.username }, 'secret', { expiresIn: '1h' });
    res.json({ token });
});

module.exports = router;


